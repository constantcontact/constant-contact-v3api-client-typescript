/* tslint:disable */
/* eslint-disable */
/**
 * Constant Contact API v3
 * Swagger build version 3.0.2475
 *
 * The version of the OpenAPI document: 1.0.85
 * Contact: webservices@constantcontact.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CreateSegment201Response } from '../models';
// @ts-ignore
import { CreateSegmentRequest } from '../models';
// @ts-ignore
import { GetAllSegments200Response } from '../models';
// @ts-ignore
import { UpdateSegmentNameRequest } from '../models';
/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this method to create a new segment. You create segments to target a subset of your contacts that meet your specific criteria for a marketing campaign. The segment `name` must be unique. The `segment_criteria` requires single-string escaped JSON. Constant Contact uses the contact data that you specify in the `segment_criteria` to evaluate and identify the contacts you want to target. Contact data can be grouped from different data sources, including:    -  **`tracking`**: Supports **or** and **and** groups.     -  **`contact`**: Supports **or** and **and** groups.     -  **`list_membership`**: Supports **or** groups.    -  **`tags`**: Supports **or** groups.  If you do not specify `list_membership` as criteria, Constant Contact evaluates all contacts in your account. To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated.  For more use case information, see the [Segments Overview](/api_guide/segments_overview.html) in the API guide.
         * @summary POST (create) a Segment
         * @param {CreateSegmentRequest} createSegmentRequest The segment &#x60;name&#x60; and &#x60;segment_criteria&#x60; (requires single-string escaped JSON).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: async (createSegmentRequest: CreateSegmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSegmentRequest' is not null or undefined
            assertParamExists('createSegment', 'createSegmentRequest', createSegmentRequest)
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to delete a segment from your account. Before deleting a segment, verify that the segment is not associated with a scheduled campaign.  Deleted segments do not display in the results when using the `GET /segments` endpoint. If you know the `segment_id`, you can use the `GET /segments/{segment_id}` endpoint to view the deleted segment\'s details. A segment\'s details are preserved for external reference purposes, such as displaying the segment name in a campaign\'s history. For more use case information, see [Delete a Segment](/api_guide/segment_delete.html) in the API guide.
         * @summary DELETE a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (segmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('deleteSegment', 'segmentId', segmentId)
            const localVarPath = `/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get a list of all segments associated with the account. You can sort segment results and limit the number of segments that display per page. Deleted segments are excluded from the results. For more use case information, see [Get All Segments](/api_guide/segment_get_all.html) in the API guide.
         * @summary GET all Segments
         * @param {string} [limit] The number of segments to return on a page.
         * @param {string} [sortBy] Specify the segment sort order to use. Sort by name (&#x60;sort_by&#x3D;name&#x60;) in ascending order, or sort by date (&#x60;sort_by&#x3D;date&#x60;) in descending order with the most recently updated segments listed first.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSegments: async (limit?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to get details about a segment, including the segment criteria. If you know the `segment_id` You can also use this method to get details about a deleted segment. For more use case information, see [Get a Segment\'s Details](/api_guide/segment_get.html) in the API guide.
         * @summary GET a Segment\'s Details
         * @param {number} segmentId The system-generated unique ID that identifies a segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById: async (segmentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('getSegmentById', 'segmentId', segmentId)
            const localVarPath = `/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update an existing segment\'s name (`name`) and/or contact selection criteria (`segment_criteria`). You must specify both the `name` and the `segment_criteria` in the request body, even if you don\'t plan to update both. The segment\'s name must be unique and the JSON must be valid (requires single-string escaped JSON). To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated. For more use case information, see [Update Segment Details](/api_guide/segment_update.html) in the API guide.
         * @summary PUT (update) a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
         * @param {CreateSegmentRequest} createSegmentRequest Include both the &#x60;name&#x60; and &#x60;segment_criteria&#x60; (single-string escaped JSON) in the body request, then make updates to either or both.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegment: async (segmentId: number, createSegmentRequest: CreateSegmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('updateSegment', 'segmentId', segmentId)
            // verify required parameter 'createSegmentRequest' is not null or undefined
            assertParamExists('updateSegment', 'createSegmentRequest', createSegmentRequest)
            const localVarPath = `/segments/{segment_id}`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to update an existing segment `name` with a new unique name in the request body. For more use case information, see [Rename a Segment](/api_guide/segment_rename.html) in the API guide.
         * @summary PATCH (rename) a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
         * @param {UpdateSegmentNameRequest} updateSegmentNameRequest Include the existing segment &#x60;name&#x60; in the body request, then rename the segment using a unique new name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegmentName: async (segmentId: number, updateSegmentNameRequest: UpdateSegmentNameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('updateSegmentName', 'segmentId', segmentId)
            // verify required parameter 'updateSegmentNameRequest' is not null or undefined
            assertParamExists('updateSegmentName', 'updateSegmentNameRequest', updateSegmentNameRequest)
            const localVarPath = `/segments/{segment_id}/name`
                .replace(`{${"segment_id"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSegmentNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this method to create a new segment. You create segments to target a subset of your contacts that meet your specific criteria for a marketing campaign. The segment `name` must be unique. The `segment_criteria` requires single-string escaped JSON. Constant Contact uses the contact data that you specify in the `segment_criteria` to evaluate and identify the contacts you want to target. Contact data can be grouped from different data sources, including:    -  **`tracking`**: Supports **or** and **and** groups.     -  **`contact`**: Supports **or** and **and** groups.     -  **`list_membership`**: Supports **or** groups.    -  **`tags`**: Supports **or** groups.  If you do not specify `list_membership` as criteria, Constant Contact evaluates all contacts in your account. To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated.  For more use case information, see the [Segments Overview](/api_guide/segments_overview.html) in the API guide.
         * @summary POST (create) a Segment
         * @param {CreateSegmentRequest} createSegmentRequest The segment &#x60;name&#x60; and &#x60;segment_criteria&#x60; (requires single-string escaped JSON).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSegment(createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSegment201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSegment(createSegmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.createSegment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to delete a segment from your account. Before deleting a segment, verify that the segment is not associated with a scheduled campaign.  Deleted segments do not display in the results when using the `GET /segments` endpoint. If you know the `segment_id`, you can use the `GET /segments/{segment_id}` endpoint to view the deleted segment\'s details. A segment\'s details are preserved for external reference purposes, such as displaying the segment name in a campaign\'s history. For more use case information, see [Delete a Segment](/api_guide/segment_delete.html) in the API guide.
         * @summary DELETE a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(segmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(segmentId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.deleteSegment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to get a list of all segments associated with the account. You can sort segment results and limit the number of segments that display per page. Deleted segments are excluded from the results. For more use case information, see [Get All Segments](/api_guide/segment_get_all.html) in the API guide.
         * @summary GET all Segments
         * @param {string} [limit] The number of segments to return on a page.
         * @param {string} [sortBy] Specify the segment sort order to use. Sort by name (&#x60;sort_by&#x3D;name&#x60;) in ascending order, or sort by date (&#x60;sort_by&#x3D;date&#x60;) in descending order with the most recently updated segments listed first.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSegments(limit?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllSegments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSegments(limit, sortBy, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.getAllSegments']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to get details about a segment, including the segment criteria. If you know the `segment_id` You can also use this method to get details about a deleted segment. For more use case information, see [Get a Segment\'s Details](/api_guide/segment_get.html) in the API guide.
         * @summary GET a Segment\'s Details
         * @param {number} segmentId The system-generated unique ID that identifies a segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentById(segmentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSegment201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentById(segmentId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.getSegmentById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to update an existing segment\'s name (`name`) and/or contact selection criteria (`segment_criteria`). You must specify both the `name` and the `segment_criteria` in the request body, even if you don\'t plan to update both. The segment\'s name must be unique and the JSON must be valid (requires single-string escaped JSON). To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated. For more use case information, see [Update Segment Details](/api_guide/segment_update.html) in the API guide.
         * @summary PUT (update) a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
         * @param {CreateSegmentRequest} createSegmentRequest Include both the &#x60;name&#x60; and &#x60;segment_criteria&#x60; (single-string escaped JSON) in the body request, then make updates to either or both.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSegment(segmentId: number, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSegment201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSegment(segmentId, createSegmentRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.updateSegment']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to update an existing segment `name` with a new unique name in the request body. For more use case information, see [Rename a Segment](/api_guide/segment_rename.html) in the API guide.
         * @summary PATCH (rename) a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
         * @param {UpdateSegmentNameRequest} updateSegmentNameRequest Include the existing segment &#x60;name&#x60; in the body request, then rename the segment using a unique new name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSegmentName(segmentId: number, updateSegmentNameRequest: UpdateSegmentNameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSegment201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSegmentName(segmentId, updateSegmentNameRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.updateSegmentName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * Use this method to create a new segment. You create segments to target a subset of your contacts that meet your specific criteria for a marketing campaign. The segment `name` must be unique. The `segment_criteria` requires single-string escaped JSON. Constant Contact uses the contact data that you specify in the `segment_criteria` to evaluate and identify the contacts you want to target. Contact data can be grouped from different data sources, including:    -  **`tracking`**: Supports **or** and **and** groups.     -  **`contact`**: Supports **or** and **and** groups.     -  **`list_membership`**: Supports **or** groups.    -  **`tags`**: Supports **or** groups.  If you do not specify `list_membership` as criteria, Constant Contact evaluates all contacts in your account. To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated.  For more use case information, see the [Segments Overview](/api_guide/segments_overview.html) in the API guide.
         * @summary POST (create) a Segment
         * @param {CreateSegmentRequest} createSegmentRequest The segment &#x60;name&#x60; and &#x60;segment_criteria&#x60; (requires single-string escaped JSON).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSegment(createSegmentRequest: CreateSegmentRequest, options?: any): AxiosPromise<CreateSegment201Response> {
            return localVarFp.createSegment(createSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to delete a segment from your account. Before deleting a segment, verify that the segment is not associated with a scheduled campaign.  Deleted segments do not display in the results when using the `GET /segments` endpoint. If you know the `segment_id`, you can use the `GET /segments/{segment_id}` endpoint to view the deleted segment\'s details. A segment\'s details are preserved for external reference purposes, such as displaying the segment name in a campaign\'s history. For more use case information, see [Delete a Segment](/api_guide/segment_delete.html) in the API guide.
         * @summary DELETE a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(segmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSegment(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get a list of all segments associated with the account. You can sort segment results and limit the number of segments that display per page. Deleted segments are excluded from the results. For more use case information, see [Get All Segments](/api_guide/segment_get_all.html) in the API guide.
         * @summary GET all Segments
         * @param {string} [limit] The number of segments to return on a page.
         * @param {string} [sortBy] Specify the segment sort order to use. Sort by name (&#x60;sort_by&#x3D;name&#x60;) in ascending order, or sort by date (&#x60;sort_by&#x3D;date&#x60;) in descending order with the most recently updated segments listed first.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSegments(limit?: string, sortBy?: string, options?: any): AxiosPromise<GetAllSegments200Response> {
            return localVarFp.getAllSegments(limit, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to get details about a segment, including the segment criteria. If you know the `segment_id` You can also use this method to get details about a deleted segment. For more use case information, see [Get a Segment\'s Details](/api_guide/segment_get.html) in the API guide.
         * @summary GET a Segment\'s Details
         * @param {number} segmentId The system-generated unique ID that identifies a segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById(segmentId: number, options?: any): AxiosPromise<CreateSegment201Response> {
            return localVarFp.getSegmentById(segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update an existing segment\'s name (`name`) and/or contact selection criteria (`segment_criteria`). You must specify both the `name` and the `segment_criteria` in the request body, even if you don\'t plan to update both. The segment\'s name must be unique and the JSON must be valid (requires single-string escaped JSON). To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated. For more use case information, see [Update Segment Details](/api_guide/segment_update.html) in the API guide.
         * @summary PUT (update) a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
         * @param {CreateSegmentRequest} createSegmentRequest Include both the &#x60;name&#x60; and &#x60;segment_criteria&#x60; (single-string escaped JSON) in the body request, then make updates to either or both.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegment(segmentId: number, createSegmentRequest: CreateSegmentRequest, options?: any): AxiosPromise<CreateSegment201Response> {
            return localVarFp.updateSegment(segmentId, createSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to update an existing segment `name` with a new unique name in the request body. For more use case information, see [Rename a Segment](/api_guide/segment_rename.html) in the API guide.
         * @summary PATCH (rename) a Segment
         * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
         * @param {UpdateSegmentNameRequest} updateSegmentNameRequest Include the existing segment &#x60;name&#x60; in the body request, then rename the segment using a unique new name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSegmentName(segmentId: number, updateSegmentNameRequest: UpdateSegmentNameRequest, options?: any): AxiosPromise<CreateSegment201Response> {
            return localVarFp.updateSegmentName(segmentId, updateSegmentNameRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * Use this method to create a new segment. You create segments to target a subset of your contacts that meet your specific criteria for a marketing campaign. The segment `name` must be unique. The `segment_criteria` requires single-string escaped JSON. Constant Contact uses the contact data that you specify in the `segment_criteria` to evaluate and identify the contacts you want to target. Contact data can be grouped from different data sources, including:    -  **`tracking`**: Supports **or** and **and** groups.     -  **`contact`**: Supports **or** and **and** groups.     -  **`list_membership`**: Supports **or** groups.    -  **`tags`**: Supports **or** groups.  If you do not specify `list_membership` as criteria, Constant Contact evaluates all contacts in your account. To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated.  For more use case information, see the [Segments Overview](/api_guide/segments_overview.html) in the API guide.
     * @summary POST (create) a Segment
     * @param {CreateSegmentRequest} createSegmentRequest The segment &#x60;name&#x60; and &#x60;segment_criteria&#x60; (requires single-string escaped JSON).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public createSegment(createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).createSegment(createSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to delete a segment from your account. Before deleting a segment, verify that the segment is not associated with a scheduled campaign.  Deleted segments do not display in the results when using the `GET /segments` endpoint. If you know the `segment_id`, you can use the `GET /segments/{segment_id}` endpoint to view the deleted segment\'s details. A segment\'s details are preserved for external reference purposes, such as displaying the segment name in a campaign\'s history. For more use case information, see [Delete a Segment](/api_guide/segment_delete.html) in the API guide.
     * @summary DELETE a Segment
     * @param {number} segmentId The system generated ID that uniquely identifies the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(segmentId: number, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get a list of all segments associated with the account. You can sort segment results and limit the number of segments that display per page. Deleted segments are excluded from the results. For more use case information, see [Get All Segments](/api_guide/segment_get_all.html) in the API guide.
     * @summary GET all Segments
     * @param {string} [limit] The number of segments to return on a page.
     * @param {string} [sortBy] Specify the segment sort order to use. Sort by name (&#x60;sort_by&#x3D;name&#x60;) in ascending order, or sort by date (&#x60;sort_by&#x3D;date&#x60;) in descending order with the most recently updated segments listed first.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getAllSegments(limit?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getAllSegments(limit, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to get details about a segment, including the segment criteria. If you know the `segment_id` You can also use this method to get details about a deleted segment. For more use case information, see [Get a Segment\'s Details](/api_guide/segment_get.html) in the API guide.
     * @summary GET a Segment\'s Details
     * @param {number} segmentId The system-generated unique ID that identifies a segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegmentById(segmentId: number, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegmentById(segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update an existing segment\'s name (`name`) and/or contact selection criteria (`segment_criteria`). You must specify both the `name` and the `segment_criteria` in the request body, even if you don\'t plan to update both. The segment\'s name must be unique and the JSON must be valid (requires single-string escaped JSON). To avoid returning a 400 error response, when specifying the `segment_criteria` do not request more than 500 email campaigns or a date range greater than 1825 days (5 years) be evaluated. For more use case information, see [Update Segment Details](/api_guide/segment_update.html) in the API guide.
     * @summary PUT (update) a Segment
     * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
     * @param {CreateSegmentRequest} createSegmentRequest Include both the &#x60;name&#x60; and &#x60;segment_criteria&#x60; (single-string escaped JSON) in the body request, then make updates to either or both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public updateSegment(segmentId: number, createSegmentRequest: CreateSegmentRequest, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).updateSegment(segmentId, createSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to update an existing segment `name` with a new unique name in the request body. For more use case information, see [Rename a Segment](/api_guide/segment_rename.html) in the API guide.
     * @summary PATCH (rename) a Segment
     * @param {number} segmentId The system generated ID that uniquely identifies the segment that you want to modify.
     * @param {UpdateSegmentNameRequest} updateSegmentNameRequest Include the existing segment &#x60;name&#x60; in the body request, then rename the segment using a unique new name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public updateSegmentName(segmentId: number, updateSegmentNameRequest: UpdateSegmentNameRequest, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).updateSegmentName(segmentId, updateSegmentNameRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

