/* tslint:disable */
/* eslint-disable */
/**
 * Constant Contact API v3
 * Swagger build version 3.0.2475
 *
 * The version of the OpenAPI document: 1.0.116
 * Contact: webservices@constantcontact.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CreateContactRequest } from '../models';
// @ts-ignore
import { CreateOrUpdateContact200Response } from '../models';
// @ts-ignore
import { CreateOrUpdateContactRequest } from '../models';
// @ts-ignore
import { GetAllContacts200Response } from '../models';
// @ts-ignore
import { GetContactById200Response } from '../models';
// @ts-ignore
import { GetContactCounts200Response } from '../models';
// @ts-ignore
import { GetContactIdXrefs200Response } from '../models';
// @ts-ignore
import { GetSmsEngagementHistory200ResponseInner } from '../models';
// @ts-ignore
import { UpdateContactRequest } from '../models';
/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new contact resource; you must include the `create_source` property and at least one of the following properties when creating a new contact: `first_name`, `last_name`, or `email_address` (`email_address` must be unique for each contact).
         * @summary POST (create) a Contact
         * @param {CreateContactRequest} createContactRequest The JSON payload defining the contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: async (createContactRequest: CreateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContactRequest' is not null or undefined
            assertParamExists('createContact', 'createContactRequest', createContactRequest)
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to create a new contact or update an existing contact. This method uses the `email_address` string value you include in the request body to determine if it should create an new contact or update an existing contact.  Updates to existing contacts are partial updates. This method only updates the contact properties you include in the request body. Updates append new contact lists or custom fields to the existing `list_memberships` or `custom_fields` arrays. <div class=\"Msg\"><p class=\"note-text\">Only use this method when a contact gives you their explicit permission to send them emails. It is a violation of US and Canadian anti-spam laws, as well as a serious violation of the Constant Contact Terms of Service to use the Opt-in features of the API to opt a contact back in without his or her own action and consent.</p></div>  When this method creates a new contact, it returns a 201 response code.  When this method updates an existing contact, it returns a 200 response code. Updating a deleted contact restores the contact.  The method automatically modifies the contact\'s `permission_to_send` and `opt_in_source` properties depending on the [Confirmed Opt-In](https://knowledgebase.constantcontact.com/articles/KnowledgeBase/5533-obtain-permission-to-send-email-campaigns-to-your-contacts-by-using-confirmed-opt-in) Constant Contact account setting:  If Confirmed Opt-in is _enabled_, this method automatically sets the `permission_to_send` property as pending\\_confirmation for new contacts.   If Confirmed Opt-in is _disabled_, this method automatically sets the `permission_to_send` property as explicit and the `opt_in_source` property as `Contact` for new contacts. Updated contacts have their `permission_to_send` property set as explicit.       
         * @summary Create or Update a Contact
         * @param {CreateOrUpdateContactRequest} createOrUpdateContactRequest A JSON request body payload that contains the contact resource you are creating or updating. The request body must contain the &#x60;email_address&#x60; property and the &#x60;list_memberships&#x60; array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateContact: async (createOrUpdateContactRequest: CreateOrUpdateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateContactRequest' is not null or undefined
            assertParamExists('createOrUpdateContact', 'createOrUpdateContactRequest', createOrUpdateContactRequest)
            const localVarPath = `/contacts/sign_up_form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the contact identified by the contact_id path parameter. Deleted contacts won\'t receive email from you, and they don\'t count as active contacts. Unlike unsubscribed contacts, deleted contacts can be revived, or added back to an account. Learn how to [revive deleted contacts](/api_guide/contacts_delete.html#revive).
         * @summary DELETE a Contact
         * @param {string} contactId Unique ID of contact to DELETE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteContact', 'contactId', contactId)
            const localVarPath = `/contacts/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to return a collection of contacts. Use the query parameters to search for contacts that match specific contact properties and subresourse properties as criteria. For example, you can search using the contact\'s `email` address, `lists` memberships, and by the date range that a contact was created or updated. Use the `limit` query parameter to limit the number of results returned per page. Use the `include` query parameter to include contact sub-resources in the response and `include_count` to include the total number of contacts that meet your specified search criteria.  By default, this method returns all contacts that are not deleted. Use the `status` query parameter with the value `all` to return all contacts including deleted contacts.
         * @summary GET Contacts Collection
         * @param {GetAllContactsStatusEnum} [status] Use the &#x60;status&#x60; query parameter to search for contacts by status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;active&#x60;, &#x60;deleted&#x60;, &#x60;not_set&#x60;, &#x60;pending_confirmation&#x60;, &#x60;temp_hold&#x60;, and &#x60;unsubscribed&#x60;.
         * @param {string} [email] Use the &#x60;email&#x60; query parameter to search for a contact using a specific email address.
         * @param {string} [lists] Use the &#x60;lists&#x60; query parameter to search for contacts that are members of one or more specified lists. Use a comma to separate multiple &#x60;list_id&#x60; values, up to a maximum of 25.
         * @param {string} [segmentId] Use to get contacts that meet the segment criteria for a single specified &#x60;segment_id&#x60;. This query parameter can only be combined with the limit query parameter. When using the &#x60;segment_id&#x60; query parameter, the V3 API may return a 202 response code instead of a 200 response. The 202 response code indicates that your request has been accepted, but not fully completed. Retry sending your API request to return the completed results and a 200 response code.
         * @param {string} [tags] Use to get contact details for up to 50 specified tags. Use a comma to separate each &#x60;tag_id&#x60;.
         * @param {string} [updatedAfter] Use &#x60;updated_after&#x60; to search for contacts that have been updated after the date you specify. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [updatedBefore] Use &#x60;updated_before&#x60; to search for contacts that have been updated before a specified date. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [createdAfter] Use &#x60;created_after&#x60; to search for contacts created after a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [createdBefore] Use &#x60;created_before&#x60; to search for contacts created before a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [optoutAfter] Use &#x60;optout_after&#x60; to search for contacts that unsubscribed after a specified date.
         * @param {string} [optoutBefore] Use &#x60;optout_before&#x60; to search for contacts that unsubscribed before a specified date.
         * @param {GetAllContactsIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;taggings&#x60;, &#x60;notes&#x60;,&#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;sms_channel&#x60;.
         * @param {GetAllContactsSmsStatusEnum} [smsStatus] Use to get contacts by their SMS status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;explicit&#x60;, &#x60;unsubscribed&#x60;, &#x60;pending_confirmation&#x60;, &#x60;not_set&#x60;.
         * @param {boolean} [includeCount] Set &#x60;include_count&#x3D;true&#x60; to include the total number of contacts (&#x60;contacts_count&#x60;) that meet all search criteria in the response body.
         * @param {number} [limit] Specifies the number of results displayed per page of output in the response, from 1 - 500, default &#x3D; 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: async (status?: GetAllContactsStatusEnum, email?: string, lists?: string, segmentId?: string, tags?: string, updatedAfter?: string, updatedBefore?: string, createdAfter?: string, createdBefore?: string, optoutAfter?: string, optoutBefore?: string, include?: GetAllContactsIncludeEnum, smsStatus?: GetAllContactsSmsStatusEnum, includeCount?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (lists !== undefined) {
                localVarQueryParameter['lists'] = lists;
            }

            if (segmentId !== undefined) {
                localVarQueryParameter['segment_id'] = segmentId;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updated_after'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (optoutAfter !== undefined) {
                localVarQueryParameter['optout_after'] = (optoutAfter as any instanceof Date) ?
                    (optoutAfter as any).toISOString() :
                    optoutAfter;
            }

            if (optoutBefore !== undefined) {
                localVarQueryParameter['optout_before'] = (optoutBefore as any instanceof Date) ?
                    (optoutBefore as any).toISOString() :
                    optoutBefore;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (smsStatus !== undefined) {
                localVarQueryParameter['sms_status'] = smsStatus;
            }

            if (includeCount !== undefined) {
                localVarQueryParameter['include_count'] = includeCount;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint GETs a specific contact resource (contact_id). Use the `include` query parameter to add any of the available contact sub-resources to the response payload.
         * @summary GET a Contact
         * @param {string} contactId Unique ID of contact to GET
         * @param {GetContactByIdIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;notes&#x60;, &#x60;sms_channel&#x60;, and &#x60;taggings&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactById: async (contactId: string, include?: GetContactByIdIncludeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getContactById', 'contactId', contactId)
            const localVarPath = `/contacts/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use to get the total contacts count for the account and the total contact-consent counts for each consent state. Optionally, to include the total number of contacts that subscribed within the last 30 days in the results, use `new_subscribers` in the `include` query parameter. To optimize open rates, reduce spam reports, and help grow your business,  you must value your contact\'s consent to receive or to not receive your emails.
         * @summary GET Contact Consent Counts
         * @param {GetContactCountsIncludeEnum} [include] Use to return the total number of contacts that subscribed within the last 30 days in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactCounts: async (include?: GetContactCountsIncludeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <div class=\"Msg Msg--warning\"><p class=\"note-text\">Use this endpoint to migrate your locally stored V2 contact ids to the new V3 format. Developers are expected to use this endpoint sparingly. This endpoint is NOT intended for regular or repeated use. Constant Contact will eventually deprecate and remove this endpoint.</p></div>  This GET call retrieves a collection of cross-referenced contact sequence IDs (`id` used in the V2 API) and UUIDs (`contact_id` used in the V3 API). This endpoint is intended for developers who have an existing V2 API integration, and are migrating their users to a new V3 API integration. The V2 and V3 APIs use different resource ID formats. Use the `sequence_ids` query parameter to specify a set of comma delimited V2 contacts ids to cross-referenced with their V3 `contact_ids`. See [Migrating to V3](/api_guide/migration_overview.html) to learn more.
         * @summary GET a collection of V2 and V3 API contact IDs
         * @param {string} sequenceIds Comma delimited list of V2 API contact &#x60;ids&#x60; to cross-reference with the V3 API &#x60;contact_id&#x60; value. Endpoint accepts a maximum of 500 ids at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactIdXrefs: async (sequenceIds: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sequenceIds' is not null or undefined
            assertParamExists('getContactIdXrefs', 'sequenceIds', sequenceIds)
            const localVarPath = `/contacts/contact_id_xrefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)

            if (sequenceIds !== undefined) {
                localVarQueryParameter['sequence_ids'] = sequenceIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to return SMS engagement details for a contact, such as SMS consent and advertising frequency details.
         * @summary GET SMS Engagement History for a Contact
         * @param {string} contactId The contact\&#39;s unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmsEngagementHistory: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getSmsEngagementHistory', 'contactId', contactId)
            const localVarPath = `/contacts/sms_engagement_history/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The PUT method updates an existing contact. You must include the `update_source` property in the PUT request payload. To restore  a deleted contact you must specify the `update_source` as `Account`. When updating any resource using PUT, all properties are updated, overwriting all previous values. Any properties left blank or not included in the request are overwritten with null value - however this does not apply to contact subresources. Add or change any of the subresources by including them in the PUT request payload. Omitted subresources are not overwritten with null. If the contact being updated is deleted, the contact will be revived.
         * @summary PUT (update) a Contact
         * @param {string} contactId Unique ID of contact to update
         * @param {UpdateContactRequest} updateContactRequest JSON payload defining the contact object, with updates. Any properties left blank or not included in the PUT payload are overwritten with null value - does not apply to contact subresources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact: async (contactId: string, updateContactRequest: UpdateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('updateContact', 'contactId', contactId)
            // verify required parameter 'updateContactRequest' is not null or undefined
            assertParamExists('updateContact', 'updateContactRequest', updateContactRequest)
            const localVarPath = `/contacts/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2_access_code required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_access_code", ["contact_data"], configuration)

            // authentication oauth2_implicit required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2_implicit", ["contact_data"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new contact resource; you must include the `create_source` property and at least one of the following properties when creating a new contact: `first_name`, `last_name`, or `email_address` (`email_address` must be unique for each contact).
         * @summary POST (create) a Contact
         * @param {CreateContactRequest} createContactRequest The JSON payload defining the contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContact(createContactRequest: CreateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContact(createContactRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.createContact']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to create a new contact or update an existing contact. This method uses the `email_address` string value you include in the request body to determine if it should create an new contact or update an existing contact.  Updates to existing contacts are partial updates. This method only updates the contact properties you include in the request body. Updates append new contact lists or custom fields to the existing `list_memberships` or `custom_fields` arrays. <div class=\"Msg\"><p class=\"note-text\">Only use this method when a contact gives you their explicit permission to send them emails. It is a violation of US and Canadian anti-spam laws, as well as a serious violation of the Constant Contact Terms of Service to use the Opt-in features of the API to opt a contact back in without his or her own action and consent.</p></div>  When this method creates a new contact, it returns a 201 response code.  When this method updates an existing contact, it returns a 200 response code. Updating a deleted contact restores the contact.  The method automatically modifies the contact\'s `permission_to_send` and `opt_in_source` properties depending on the [Confirmed Opt-In](https://knowledgebase.constantcontact.com/articles/KnowledgeBase/5533-obtain-permission-to-send-email-campaigns-to-your-contacts-by-using-confirmed-opt-in) Constant Contact account setting:  If Confirmed Opt-in is _enabled_, this method automatically sets the `permission_to_send` property as pending\\_confirmation for new contacts.   If Confirmed Opt-in is _disabled_, this method automatically sets the `permission_to_send` property as explicit and the `opt_in_source` property as `Contact` for new contacts. Updated contacts have their `permission_to_send` property set as explicit.       
         * @summary Create or Update a Contact
         * @param {CreateOrUpdateContactRequest} createOrUpdateContactRequest A JSON request body payload that contains the contact resource you are creating or updating. The request body must contain the &#x60;email_address&#x60; property and the &#x60;list_memberships&#x60; array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateContact(createOrUpdateContactRequest: CreateOrUpdateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateContact(createOrUpdateContactRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.createOrUpdateContact']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes the contact identified by the contact_id path parameter. Deleted contacts won\'t receive email from you, and they don\'t count as active contacts. Unlike unsubscribed contacts, deleted contacts can be revived, or added back to an account. Learn how to [revive deleted contacts](/api_guide/contacts_delete.html#revive).
         * @summary DELETE a Contact
         * @param {string} contactId Unique ID of contact to DELETE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContact(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContact(contactId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.deleteContact']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to return a collection of contacts. Use the query parameters to search for contacts that match specific contact properties and subresourse properties as criteria. For example, you can search using the contact\'s `email` address, `lists` memberships, and by the date range that a contact was created or updated. Use the `limit` query parameter to limit the number of results returned per page. Use the `include` query parameter to include contact sub-resources in the response and `include_count` to include the total number of contacts that meet your specified search criteria.  By default, this method returns all contacts that are not deleted. Use the `status` query parameter with the value `all` to return all contacts including deleted contacts.
         * @summary GET Contacts Collection
         * @param {GetAllContactsStatusEnum} [status] Use the &#x60;status&#x60; query parameter to search for contacts by status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;active&#x60;, &#x60;deleted&#x60;, &#x60;not_set&#x60;, &#x60;pending_confirmation&#x60;, &#x60;temp_hold&#x60;, and &#x60;unsubscribed&#x60;.
         * @param {string} [email] Use the &#x60;email&#x60; query parameter to search for a contact using a specific email address.
         * @param {string} [lists] Use the &#x60;lists&#x60; query parameter to search for contacts that are members of one or more specified lists. Use a comma to separate multiple &#x60;list_id&#x60; values, up to a maximum of 25.
         * @param {string} [segmentId] Use to get contacts that meet the segment criteria for a single specified &#x60;segment_id&#x60;. This query parameter can only be combined with the limit query parameter. When using the &#x60;segment_id&#x60; query parameter, the V3 API may return a 202 response code instead of a 200 response. The 202 response code indicates that your request has been accepted, but not fully completed. Retry sending your API request to return the completed results and a 200 response code.
         * @param {string} [tags] Use to get contact details for up to 50 specified tags. Use a comma to separate each &#x60;tag_id&#x60;.
         * @param {string} [updatedAfter] Use &#x60;updated_after&#x60; to search for contacts that have been updated after the date you specify. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [updatedBefore] Use &#x60;updated_before&#x60; to search for contacts that have been updated before a specified date. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [createdAfter] Use &#x60;created_after&#x60; to search for contacts created after a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [createdBefore] Use &#x60;created_before&#x60; to search for contacts created before a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [optoutAfter] Use &#x60;optout_after&#x60; to search for contacts that unsubscribed after a specified date.
         * @param {string} [optoutBefore] Use &#x60;optout_before&#x60; to search for contacts that unsubscribed before a specified date.
         * @param {GetAllContactsIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;taggings&#x60;, &#x60;notes&#x60;,&#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;sms_channel&#x60;.
         * @param {GetAllContactsSmsStatusEnum} [smsStatus] Use to get contacts by their SMS status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;explicit&#x60;, &#x60;unsubscribed&#x60;, &#x60;pending_confirmation&#x60;, &#x60;not_set&#x60;.
         * @param {boolean} [includeCount] Set &#x60;include_count&#x3D;true&#x60; to include the total number of contacts (&#x60;contacts_count&#x60;) that meet all search criteria in the response body.
         * @param {number} [limit] Specifies the number of results displayed per page of output in the response, from 1 - 500, default &#x3D; 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContacts(status?: GetAllContactsStatusEnum, email?: string, lists?: string, segmentId?: string, tags?: string, updatedAfter?: string, updatedBefore?: string, createdAfter?: string, createdBefore?: string, optoutAfter?: string, optoutBefore?: string, include?: GetAllContactsIncludeEnum, smsStatus?: GetAllContactsSmsStatusEnum, includeCount?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllContacts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContacts(status, email, lists, segmentId, tags, updatedAfter, updatedBefore, createdAfter, createdBefore, optoutAfter, optoutBefore, include, smsStatus, includeCount, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.getAllContacts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This endpoint GETs a specific contact resource (contact_id). Use the `include` query parameter to add any of the available contact sub-resources to the response payload.
         * @summary GET a Contact
         * @param {string} contactId Unique ID of contact to GET
         * @param {GetContactByIdIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;notes&#x60;, &#x60;sms_channel&#x60;, and &#x60;taggings&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactById(contactId: string, include?: GetContactByIdIncludeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactById(contactId, include, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.getContactById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use to get the total contacts count for the account and the total contact-consent counts for each consent state. Optionally, to include the total number of contacts that subscribed within the last 30 days in the results, use `new_subscribers` in the `include` query parameter. To optimize open rates, reduce spam reports, and help grow your business,  you must value your contact\'s consent to receive or to not receive your emails.
         * @summary GET Contact Consent Counts
         * @param {GetContactCountsIncludeEnum} [include] Use to return the total number of contacts that subscribed within the last 30 days in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactCounts(include?: GetContactCountsIncludeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactCounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactCounts(include, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.getContactCounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * <div class=\"Msg Msg--warning\"><p class=\"note-text\">Use this endpoint to migrate your locally stored V2 contact ids to the new V3 format. Developers are expected to use this endpoint sparingly. This endpoint is NOT intended for regular or repeated use. Constant Contact will eventually deprecate and remove this endpoint.</p></div>  This GET call retrieves a collection of cross-referenced contact sequence IDs (`id` used in the V2 API) and UUIDs (`contact_id` used in the V3 API). This endpoint is intended for developers who have an existing V2 API integration, and are migrating their users to a new V3 API integration. The V2 and V3 APIs use different resource ID formats. Use the `sequence_ids` query parameter to specify a set of comma delimited V2 contacts ids to cross-referenced with their V3 `contact_ids`. See [Migrating to V3](/api_guide/migration_overview.html) to learn more.
         * @summary GET a collection of V2 and V3 API contact IDs
         * @param {string} sequenceIds Comma delimited list of V2 API contact &#x60;ids&#x60; to cross-reference with the V3 API &#x60;contact_id&#x60; value. Endpoint accepts a maximum of 500 ids at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactIdXrefs(sequenceIds: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactIdXrefs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactIdXrefs(sequenceIds, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.getContactIdXrefs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Use this method to return SMS engagement details for a contact, such as SMS consent and advertising frequency details.
         * @summary GET SMS Engagement History for a Contact
         * @param {string} contactId The contact\&#39;s unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSmsEngagementHistory(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSmsEngagementHistory200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmsEngagementHistory(contactId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.getSmsEngagementHistory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The PUT method updates an existing contact. You must include the `update_source` property in the PUT request payload. To restore  a deleted contact you must specify the `update_source` as `Account`. When updating any resource using PUT, all properties are updated, overwriting all previous values. Any properties left blank or not included in the request are overwritten with null value - however this does not apply to contact subresources. Add or change any of the subresources by including them in the PUT request payload. Omitted subresources are not overwritten with null. If the contact being updated is deleted, the contact will be revived.
         * @summary PUT (update) a Contact
         * @param {string} contactId Unique ID of contact to update
         * @param {UpdateContactRequest} updateContactRequest JSON payload defining the contact object, with updates. Any properties left blank or not included in the PUT payload are overwritten with null value - does not apply to contact subresources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContact(contactId: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContact(contactId, updateContactRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContactsApi.updateContact']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Creates a new contact resource; you must include the `create_source` property and at least one of the following properties when creating a new contact: `first_name`, `last_name`, or `email_address` (`email_address` must be unique for each contact).
         * @summary POST (create) a Contact
         * @param {CreateContactRequest} createContactRequest The JSON payload defining the contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(createContactRequest: CreateContactRequest, options?: any): AxiosPromise<GetContactById200Response> {
            return localVarFp.createContact(createContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to create a new contact or update an existing contact. This method uses the `email_address` string value you include in the request body to determine if it should create an new contact or update an existing contact.  Updates to existing contacts are partial updates. This method only updates the contact properties you include in the request body. Updates append new contact lists or custom fields to the existing `list_memberships` or `custom_fields` arrays. <div class=\"Msg\"><p class=\"note-text\">Only use this method when a contact gives you their explicit permission to send them emails. It is a violation of US and Canadian anti-spam laws, as well as a serious violation of the Constant Contact Terms of Service to use the Opt-in features of the API to opt a contact back in without his or her own action and consent.</p></div>  When this method creates a new contact, it returns a 201 response code.  When this method updates an existing contact, it returns a 200 response code. Updating a deleted contact restores the contact.  The method automatically modifies the contact\'s `permission_to_send` and `opt_in_source` properties depending on the [Confirmed Opt-In](https://knowledgebase.constantcontact.com/articles/KnowledgeBase/5533-obtain-permission-to-send-email-campaigns-to-your-contacts-by-using-confirmed-opt-in) Constant Contact account setting:  If Confirmed Opt-in is _enabled_, this method automatically sets the `permission_to_send` property as pending\\_confirmation for new contacts.   If Confirmed Opt-in is _disabled_, this method automatically sets the `permission_to_send` property as explicit and the `opt_in_source` property as `Contact` for new contacts. Updated contacts have their `permission_to_send` property set as explicit.       
         * @summary Create or Update a Contact
         * @param {CreateOrUpdateContactRequest} createOrUpdateContactRequest A JSON request body payload that contains the contact resource you are creating or updating. The request body must contain the &#x60;email_address&#x60; property and the &#x60;list_memberships&#x60; array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateContact(createOrUpdateContactRequest: CreateOrUpdateContactRequest, options?: any): AxiosPromise<CreateOrUpdateContact200Response> {
            return localVarFp.createOrUpdateContact(createOrUpdateContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the contact identified by the contact_id path parameter. Deleted contacts won\'t receive email from you, and they don\'t count as active contacts. Unlike unsubscribed contacts, deleted contacts can be revived, or added back to an account. Learn how to [revive deleted contacts](/api_guide/contacts_delete.html#revive).
         * @summary DELETE a Contact
         * @param {string} contactId Unique ID of contact to DELETE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(contactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContact(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to return a collection of contacts. Use the query parameters to search for contacts that match specific contact properties and subresourse properties as criteria. For example, you can search using the contact\'s `email` address, `lists` memberships, and by the date range that a contact was created or updated. Use the `limit` query parameter to limit the number of results returned per page. Use the `include` query parameter to include contact sub-resources in the response and `include_count` to include the total number of contacts that meet your specified search criteria.  By default, this method returns all contacts that are not deleted. Use the `status` query parameter with the value `all` to return all contacts including deleted contacts.
         * @summary GET Contacts Collection
         * @param {GetAllContactsStatusEnum} [status] Use the &#x60;status&#x60; query parameter to search for contacts by status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;active&#x60;, &#x60;deleted&#x60;, &#x60;not_set&#x60;, &#x60;pending_confirmation&#x60;, &#x60;temp_hold&#x60;, and &#x60;unsubscribed&#x60;.
         * @param {string} [email] Use the &#x60;email&#x60; query parameter to search for a contact using a specific email address.
         * @param {string} [lists] Use the &#x60;lists&#x60; query parameter to search for contacts that are members of one or more specified lists. Use a comma to separate multiple &#x60;list_id&#x60; values, up to a maximum of 25.
         * @param {string} [segmentId] Use to get contacts that meet the segment criteria for a single specified &#x60;segment_id&#x60;. This query parameter can only be combined with the limit query parameter. When using the &#x60;segment_id&#x60; query parameter, the V3 API may return a 202 response code instead of a 200 response. The 202 response code indicates that your request has been accepted, but not fully completed. Retry sending your API request to return the completed results and a 200 response code.
         * @param {string} [tags] Use to get contact details for up to 50 specified tags. Use a comma to separate each &#x60;tag_id&#x60;.
         * @param {string} [updatedAfter] Use &#x60;updated_after&#x60; to search for contacts that have been updated after the date you specify. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [updatedBefore] Use &#x60;updated_before&#x60; to search for contacts that have been updated before a specified date. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [createdAfter] Use &#x60;created_after&#x60; to search for contacts created after a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [createdBefore] Use &#x60;created_before&#x60; to search for contacts created before a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
         * @param {string} [optoutAfter] Use &#x60;optout_after&#x60; to search for contacts that unsubscribed after a specified date.
         * @param {string} [optoutBefore] Use &#x60;optout_before&#x60; to search for contacts that unsubscribed before a specified date.
         * @param {GetAllContactsIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;taggings&#x60;, &#x60;notes&#x60;,&#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;sms_channel&#x60;.
         * @param {GetAllContactsSmsStatusEnum} [smsStatus] Use to get contacts by their SMS status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;explicit&#x60;, &#x60;unsubscribed&#x60;, &#x60;pending_confirmation&#x60;, &#x60;not_set&#x60;.
         * @param {boolean} [includeCount] Set &#x60;include_count&#x3D;true&#x60; to include the total number of contacts (&#x60;contacts_count&#x60;) that meet all search criteria in the response body.
         * @param {number} [limit] Specifies the number of results displayed per page of output in the response, from 1 - 500, default &#x3D; 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(status?: GetAllContactsStatusEnum, email?: string, lists?: string, segmentId?: string, tags?: string, updatedAfter?: string, updatedBefore?: string, createdAfter?: string, createdBefore?: string, optoutAfter?: string, optoutBefore?: string, include?: GetAllContactsIncludeEnum, smsStatus?: GetAllContactsSmsStatusEnum, includeCount?: boolean, limit?: number, options?: any): AxiosPromise<GetAllContacts200Response> {
            return localVarFp.getAllContacts(status, email, lists, segmentId, tags, updatedAfter, updatedBefore, createdAfter, createdBefore, optoutAfter, optoutBefore, include, smsStatus, includeCount, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint GETs a specific contact resource (contact_id). Use the `include` query parameter to add any of the available contact sub-resources to the response payload.
         * @summary GET a Contact
         * @param {string} contactId Unique ID of contact to GET
         * @param {GetContactByIdIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;notes&#x60;, &#x60;sms_channel&#x60;, and &#x60;taggings&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactById(contactId: string, include?: GetContactByIdIncludeEnum, options?: any): AxiosPromise<GetContactById200Response> {
            return localVarFp.getContactById(contactId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Use to get the total contacts count for the account and the total contact-consent counts for each consent state. Optionally, to include the total number of contacts that subscribed within the last 30 days in the results, use `new_subscribers` in the `include` query parameter. To optimize open rates, reduce spam reports, and help grow your business,  you must value your contact\'s consent to receive or to not receive your emails.
         * @summary GET Contact Consent Counts
         * @param {GetContactCountsIncludeEnum} [include] Use to return the total number of contacts that subscribed within the last 30 days in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactCounts(include?: GetContactCountsIncludeEnum, options?: any): AxiosPromise<GetContactCounts200Response> {
            return localVarFp.getContactCounts(include, options).then((request) => request(axios, basePath));
        },
        /**
         * <div class=\"Msg Msg--warning\"><p class=\"note-text\">Use this endpoint to migrate your locally stored V2 contact ids to the new V3 format. Developers are expected to use this endpoint sparingly. This endpoint is NOT intended for regular or repeated use. Constant Contact will eventually deprecate and remove this endpoint.</p></div>  This GET call retrieves a collection of cross-referenced contact sequence IDs (`id` used in the V2 API) and UUIDs (`contact_id` used in the V3 API). This endpoint is intended for developers who have an existing V2 API integration, and are migrating their users to a new V3 API integration. The V2 and V3 APIs use different resource ID formats. Use the `sequence_ids` query parameter to specify a set of comma delimited V2 contacts ids to cross-referenced with their V3 `contact_ids`. See [Migrating to V3](/api_guide/migration_overview.html) to learn more.
         * @summary GET a collection of V2 and V3 API contact IDs
         * @param {string} sequenceIds Comma delimited list of V2 API contact &#x60;ids&#x60; to cross-reference with the V3 API &#x60;contact_id&#x60; value. Endpoint accepts a maximum of 500 ids at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactIdXrefs(sequenceIds: string, options?: any): AxiosPromise<GetContactIdXrefs200Response> {
            return localVarFp.getContactIdXrefs(sequenceIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to return SMS engagement details for a contact, such as SMS consent and advertising frequency details.
         * @summary GET SMS Engagement History for a Contact
         * @param {string} contactId The contact\&#39;s unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmsEngagementHistory(contactId: string, options?: any): AxiosPromise<Array<GetSmsEngagementHistory200ResponseInner>> {
            return localVarFp.getSmsEngagementHistory(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * The PUT method updates an existing contact. You must include the `update_source` property in the PUT request payload. To restore  a deleted contact you must specify the `update_source` as `Account`. When updating any resource using PUT, all properties are updated, overwriting all previous values. Any properties left blank or not included in the request are overwritten with null value - however this does not apply to contact subresources. Add or change any of the subresources by including them in the PUT request payload. Omitted subresources are not overwritten with null. If the contact being updated is deleted, the contact will be revived.
         * @summary PUT (update) a Contact
         * @param {string} contactId Unique ID of contact to update
         * @param {UpdateContactRequest} updateContactRequest JSON payload defining the contact object, with updates. Any properties left blank or not included in the PUT payload are overwritten with null value - does not apply to contact subresources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(contactId: string, updateContactRequest: UpdateContactRequest, options?: any): AxiosPromise<GetContactById200Response> {
            return localVarFp.updateContact(contactId, updateContactRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Creates a new contact resource; you must include the `create_source` property and at least one of the following properties when creating a new contact: `first_name`, `last_name`, or `email_address` (`email_address` must be unique for each contact).
     * @summary POST (create) a Contact
     * @param {CreateContactRequest} createContactRequest The JSON payload defining the contact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public createContact(createContactRequest: CreateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createContact(createContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to create a new contact or update an existing contact. This method uses the `email_address` string value you include in the request body to determine if it should create an new contact or update an existing contact.  Updates to existing contacts are partial updates. This method only updates the contact properties you include in the request body. Updates append new contact lists or custom fields to the existing `list_memberships` or `custom_fields` arrays. <div class=\"Msg\"><p class=\"note-text\">Only use this method when a contact gives you their explicit permission to send them emails. It is a violation of US and Canadian anti-spam laws, as well as a serious violation of the Constant Contact Terms of Service to use the Opt-in features of the API to opt a contact back in without his or her own action and consent.</p></div>  When this method creates a new contact, it returns a 201 response code.  When this method updates an existing contact, it returns a 200 response code. Updating a deleted contact restores the contact.  The method automatically modifies the contact\'s `permission_to_send` and `opt_in_source` properties depending on the [Confirmed Opt-In](https://knowledgebase.constantcontact.com/articles/KnowledgeBase/5533-obtain-permission-to-send-email-campaigns-to-your-contacts-by-using-confirmed-opt-in) Constant Contact account setting:  If Confirmed Opt-in is _enabled_, this method automatically sets the `permission_to_send` property as pending\\_confirmation for new contacts.   If Confirmed Opt-in is _disabled_, this method automatically sets the `permission_to_send` property as explicit and the `opt_in_source` property as `Contact` for new contacts. Updated contacts have their `permission_to_send` property set as explicit.       
     * @summary Create or Update a Contact
     * @param {CreateOrUpdateContactRequest} createOrUpdateContactRequest A JSON request body payload that contains the contact resource you are creating or updating. The request body must contain the &#x60;email_address&#x60; property and the &#x60;list_memberships&#x60; array.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public createOrUpdateContact(createOrUpdateContactRequest: CreateOrUpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createOrUpdateContact(createOrUpdateContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the contact identified by the contact_id path parameter. Deleted contacts won\'t receive email from you, and they don\'t count as active contacts. Unlike unsubscribed contacts, deleted contacts can be revived, or added back to an account. Learn how to [revive deleted contacts](/api_guide/contacts_delete.html#revive).
     * @summary DELETE a Contact
     * @param {string} contactId Unique ID of contact to DELETE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public deleteContact(contactId: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).deleteContact(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to return a collection of contacts. Use the query parameters to search for contacts that match specific contact properties and subresourse properties as criteria. For example, you can search using the contact\'s `email` address, `lists` memberships, and by the date range that a contact was created or updated. Use the `limit` query parameter to limit the number of results returned per page. Use the `include` query parameter to include contact sub-resources in the response and `include_count` to include the total number of contacts that meet your specified search criteria.  By default, this method returns all contacts that are not deleted. Use the `status` query parameter with the value `all` to return all contacts including deleted contacts.
     * @summary GET Contacts Collection
     * @param {GetAllContactsStatusEnum} [status] Use the &#x60;status&#x60; query parameter to search for contacts by status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;active&#x60;, &#x60;deleted&#x60;, &#x60;not_set&#x60;, &#x60;pending_confirmation&#x60;, &#x60;temp_hold&#x60;, and &#x60;unsubscribed&#x60;.
     * @param {string} [email] Use the &#x60;email&#x60; query parameter to search for a contact using a specific email address.
     * @param {string} [lists] Use the &#x60;lists&#x60; query parameter to search for contacts that are members of one or more specified lists. Use a comma to separate multiple &#x60;list_id&#x60; values, up to a maximum of 25.
     * @param {string} [segmentId] Use to get contacts that meet the segment criteria for a single specified &#x60;segment_id&#x60;. This query parameter can only be combined with the limit query parameter. When using the &#x60;segment_id&#x60; query parameter, the V3 API may return a 202 response code instead of a 200 response. The 202 response code indicates that your request has been accepted, but not fully completed. Retry sending your API request to return the completed results and a 200 response code.
     * @param {string} [tags] Use to get contact details for up to 50 specified tags. Use a comma to separate each &#x60;tag_id&#x60;.
     * @param {string} [updatedAfter] Use &#x60;updated_after&#x60; to search for contacts that have been updated after the date you specify. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
     * @param {string} [updatedBefore] Use &#x60;updated_before&#x60; to search for contacts that have been updated before a specified date. To search for updated contacts within a date range, specify both &#x60;updated_after&#x60; and &#x60;updated_before&#x60; dates. Accepts ISO-8601 formatted dates.
     * @param {string} [createdAfter] Use &#x60;created_after&#x60; to search for contacts created after a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
     * @param {string} [createdBefore] Use &#x60;created_before&#x60; to search for contacts created before a specified date. To search for contacts created within a date range, specify both &#x60;created_after&#x60; and &#x60;created_before&#x60; dates. Accepts ISO-8601 formatted dates.
     * @param {string} [optoutAfter] Use &#x60;optout_after&#x60; to search for contacts that unsubscribed after a specified date.
     * @param {string} [optoutBefore] Use &#x60;optout_before&#x60; to search for contacts that unsubscribed before a specified date.
     * @param {GetAllContactsIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;taggings&#x60;, &#x60;notes&#x60;,&#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;sms_channel&#x60;.
     * @param {GetAllContactsSmsStatusEnum} [smsStatus] Use to get contacts by their SMS status. This parameter accepts one or more comma separated values: &#x60;all&#x60;, &#x60;explicit&#x60;, &#x60;unsubscribed&#x60;, &#x60;pending_confirmation&#x60;, &#x60;not_set&#x60;.
     * @param {boolean} [includeCount] Set &#x60;include_count&#x3D;true&#x60; to include the total number of contacts (&#x60;contacts_count&#x60;) that meet all search criteria in the response body.
     * @param {number} [limit] Specifies the number of results displayed per page of output in the response, from 1 - 500, default &#x3D; 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getAllContacts(status?: GetAllContactsStatusEnum, email?: string, lists?: string, segmentId?: string, tags?: string, updatedAfter?: string, updatedBefore?: string, createdAfter?: string, createdBefore?: string, optoutAfter?: string, optoutBefore?: string, include?: GetAllContactsIncludeEnum, smsStatus?: GetAllContactsSmsStatusEnum, includeCount?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getAllContacts(status, email, lists, segmentId, tags, updatedAfter, updatedBefore, createdAfter, createdBefore, optoutAfter, optoutBefore, include, smsStatus, includeCount, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint GETs a specific contact resource (contact_id). Use the `include` query parameter to add any of the available contact sub-resources to the response payload.
     * @summary GET a Contact
     * @param {string} contactId Unique ID of contact to GET
     * @param {GetContactByIdIncludeEnum} [include] Use &#x60;include&#x60; to specify which contact sub-resources to include in the response. Use a comma to separate multiple sub-resources. Valid values: &#x60;custom_fields&#x60;, &#x60;list_memberships&#x60;, &#x60;phone_numbers&#x60;, &#x60;street_addresses&#x60;, &#x60;notes&#x60;, &#x60;sms_channel&#x60;, and &#x60;taggings&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContactById(contactId: string, include?: GetContactByIdIncludeEnum, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContactById(contactId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use to get the total contacts count for the account and the total contact-consent counts for each consent state. Optionally, to include the total number of contacts that subscribed within the last 30 days in the results, use `new_subscribers` in the `include` query parameter. To optimize open rates, reduce spam reports, and help grow your business,  you must value your contact\'s consent to receive or to not receive your emails.
     * @summary GET Contact Consent Counts
     * @param {GetContactCountsIncludeEnum} [include] Use to return the total number of contacts that subscribed within the last 30 days in the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContactCounts(include?: GetContactCountsIncludeEnum, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContactCounts(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <div class=\"Msg Msg--warning\"><p class=\"note-text\">Use this endpoint to migrate your locally stored V2 contact ids to the new V3 format. Developers are expected to use this endpoint sparingly. This endpoint is NOT intended for regular or repeated use. Constant Contact will eventually deprecate and remove this endpoint.</p></div>  This GET call retrieves a collection of cross-referenced contact sequence IDs (`id` used in the V2 API) and UUIDs (`contact_id` used in the V3 API). This endpoint is intended for developers who have an existing V2 API integration, and are migrating their users to a new V3 API integration. The V2 and V3 APIs use different resource ID formats. Use the `sequence_ids` query parameter to specify a set of comma delimited V2 contacts ids to cross-referenced with their V3 `contact_ids`. See [Migrating to V3](/api_guide/migration_overview.html) to learn more.
     * @summary GET a collection of V2 and V3 API contact IDs
     * @param {string} sequenceIds Comma delimited list of V2 API contact &#x60;ids&#x60; to cross-reference with the V3 API &#x60;contact_id&#x60; value. Endpoint accepts a maximum of 500 ids at a time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContactIdXrefs(sequenceIds: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContactIdXrefs(sequenceIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to return SMS engagement details for a contact, such as SMS consent and advertising frequency details.
     * @summary GET SMS Engagement History for a Contact
     * @param {string} contactId The contact\&#39;s unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getSmsEngagementHistory(contactId: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getSmsEngagementHistory(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The PUT method updates an existing contact. You must include the `update_source` property in the PUT request payload. To restore  a deleted contact you must specify the `update_source` as `Account`. When updating any resource using PUT, all properties are updated, overwriting all previous values. Any properties left blank or not included in the request are overwritten with null value - however this does not apply to contact subresources. Add or change any of the subresources by including them in the PUT request payload. Omitted subresources are not overwritten with null. If the contact being updated is deleted, the contact will be revived.
     * @summary PUT (update) a Contact
     * @param {string} contactId Unique ID of contact to update
     * @param {UpdateContactRequest} updateContactRequest JSON payload defining the contact object, with updates. Any properties left blank or not included in the PUT payload are overwritten with null value - does not apply to contact subresources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public updateContact(contactId: string, updateContactRequest: UpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).updateContact(contactId, updateContactRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllContactsStatusEnum = {
    All: 'all',
    Active: 'active',
    Deleted: 'deleted',
    NotSet: 'not_set',
    PendingConfirmation: 'pending_confirmation',
    TempHold: 'temp_hold',
    Unsubscribed: 'unsubscribed'
} as const;
export type GetAllContactsStatusEnum = typeof GetAllContactsStatusEnum[keyof typeof GetAllContactsStatusEnum];
/**
 * @export
 */
export const GetAllContactsIncludeEnum = {
    CustomFields: 'custom_fields',
    ListMemberships: 'list_memberships',
    PhoneNumbers: 'phone_numbers',
    StreetAddresses: 'street_addresses',
    Taggings: 'taggings',
    Notes: 'notes',
    SmsChannel: 'sms_channel'
} as const;
export type GetAllContactsIncludeEnum = typeof GetAllContactsIncludeEnum[keyof typeof GetAllContactsIncludeEnum];
/**
 * @export
 */
export const GetAllContactsSmsStatusEnum = {
    All: 'all',
    Explicit: 'explicit',
    Unsubscribed: 'unsubscribed',
    PendingConfirmation: 'pending_confirmation',
    NotSet: 'not_set'
} as const;
export type GetAllContactsSmsStatusEnum = typeof GetAllContactsSmsStatusEnum[keyof typeof GetAllContactsSmsStatusEnum];
/**
 * @export
 */
export const GetContactByIdIncludeEnum = {
    CustomFields: 'custom_fields',
    ListMemberships: 'list_memberships',
    PhoneNumbers: 'phone_numbers',
    StreetAddresses: 'street_addresses',
    Taggings: 'taggings',
    Notes: 'notes'
} as const;
export type GetContactByIdIncludeEnum = typeof GetContactByIdIncludeEnum[keyof typeof GetContactByIdIncludeEnum];
/**
 * @export
 */
export const GetContactCountsIncludeEnum = {
    NewSubscriber: 'new_subscriber'
} as const;
export type GetContactCountsIncludeEnum = typeof GetContactCountsIncludeEnum[keyof typeof GetContactCountsIncludeEnum];
